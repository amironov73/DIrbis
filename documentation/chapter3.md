### MarcRecord, RecordField и SubField

#### MarcRecord

Каждый экземпляр `MarcRecord` соответствует одной записи в базе данных ИРБИС. Он содержит следующие поля:

Поле          |Тип              |Назначение
--------------|-----------------|----------
database      | string          | Имя базы данных, из которой загружена данная запись. Для вновь созданных записей пустая строка.
mfn           | int             | Номер записи в мастер-файле. Для вновь созданных записей 0.
status        | int             | Статус записи: логически удалена, отсутствует (см. ниже).
versionNumber | int             | Номер версии записи.
fields        | RecordField\[\] | Слайс полей записи.

Статус записи: набор флагов

Имя|Число|Значение
---|-----|--------
LOGICALLY_DELETED       | 1   | Логически удалена (может быть восстановлена).
PHYSICALLY_DELETED      | 2   | Физически удалена (не может быть восстановлена).
ABSENT                  | 4   | Отсутствует.
NON_ACTUALIZED          | 8   | Не актуализирована.
NEW_RECORD              | 16  | Первый экземпляр записи (флаг фактически не используется).
LAST                    | 32  | Последняя версия записи.
LOCKED                  | 64  | Запись заблокирована на ввод.
AUTOIN_ERROR            | 128 | Ошибка в Autoin.gbl.
FULLTEXT_NOT_ACTUALIZED | 256 | Полный текст не актуализирован.

**RecordField append(int tag, string value="")** -- добавляет в конец записи поле с указанными меткой и значением. Возвращает добавленное поле, поэтому может использоваться для "цепочечных" вызовов методов, добавляющих подполя в это поле (см. пример ниже).

**MarcRecord appendNonEmpty(int tag, string value)** -- добавляет в конец записи поле с указанными меткой и значением при условии, что значение не пустое.

**MarcRecord clear()** -- очищает запись (удаляет все поля). Остальные атрибуты записи (MFN, статус, версия) остаются неизменными.

**MarcRecord clone() const** -- клонирует запись со всеми полями (полная глубокая копия записи).

**void decode(const string[] lines)** -- декодирование записи из протокольного представления.

**bool deleted() const** -- проверка статуса, не удалена ли запись.

**string encode(string delimiter=IRBIS_DELIMITER)** -- кодирование записи в протокольное представление.

**string fm(int tag, char code=0) const** -- получение значения поля/подполя с указанными меткой и кодом. Если поле/подполе не найдено, возвращается `null`.

**pure string[] fma(int tag, char code=0)** -- получение слайса со значениями полей с указанной меткой. Если поля не найдены, возвращается пустой слайс.

**RecordField getField(int tag, int occurrence=0)** -- получение указанного повторения поля с указанной меткой. Если поле не найдено, возвращает `null`.

**RecordField[] getFields(int tag)** -- получение слайса полей с указанной меткой. Если поля не найдены, возвращается пустой массив.

**bool haveField(int tag) const** -- выясняет, есть ли в записи поле с указанной меткой.

**bool haveSubField(int tag, char code) const** -- выясняет, есть ли в записи указанное подполе.

**MarcRecord insertAt(size_t index, RecordField field)** -- вставляет поле в указанную позицию.

**MarcRecord removeAt(size_t index)** -- удаляет поле в указанной позиции.

**MarcRecord removeField(int tag)** -- удаляет все поля с указанной меткой.

**MarcRecord reset() nothrow** -- сброс состояния записи (MFN, статус, номер версии), отвязка её от базы данных. Поля данных остаются при этом нетронутыми.

**MarcRecord setField(int tag, string value)** -- устанавливает значение первого повторения поля с указанной меткой. Если такого поля нет, оно создаётся.

**MarcRecord setSubField(int tag, char code, string value)** -- устанавливает значение указанного подполя первого повторения поля с указанной меткой. Если такого поля/подполя нет, оно создаётся.

**string toString() const** -- выдаёт строковое представление записи.

**bool verify() const** -- проверяет, правильно ли сформированы поля записи (и все их подполя).

```d
auto record = new MarcRecord;
record.append(700)
    .append('a', "Миронов")
    .append('b', "А. В.")
    .append('g', "Алексей Владимирович");
record.append(200)
    .append('a', "Заглавие книги")
    .append('e', "подзаголовочные сведения");
```

#### RecordField

Каждый экземпляр класса `RecordField` соответствует одному полю записи. Содержит числовую метку, строковое значение до первого разделителя (может быть пустым) и произвольное количество подполей.

Поле      |Тип           |Назначение
----------|--------------|----------
tag       | int          | Метка поля.
value     | string       | Значение поля до первого разделителя.
subfields | SubField\[\] | Слайс подполей.

**this(int tag=0, string value="")** -- конструктор поля, создаёт поле с указанными меткой и значением.

**RecordField append(char code, string value)** -- добавляет подполе с указанными кодом и значением к полю. Возвращает `this`, так что может испольоваться для "цепочечных" вызовов.

**RecordField adppendNonEmpty(char code, string value)** -- добавляет подполе, при условии, что его значение не пустое.

**RecordField clear()** -- очищает поле (удаляет значение и все подполя). Метка поля остаётся нетронутой. Возвращает `this`.

**RecordField clone() const** -- клонирует поле со всеми подполями.

**void decodeBody(string bodyText)** -- декодирует только текст поля и подполей (без метки).

**void decode(string text)** -- декодирует поле из протокольного представления (метку, значение и подполя).

**RecordField[] getEmbeddedFields() const** -- получает слайс встроенных полей из данного поля.

**SubField getFirstSubField(char code)** -- возвращает первое вхождение подполя с указанным кодом или `nil`.

**string getFirstSubFieldValue(char code)** -- возвращает значение первого вхождения подполя с указанным кодом или пустую строку.

**string getValueOrFirstSubField()** -- выдаёт значение для ^*.

**bool haveSubField(char code) const** -- выясняет, есть ли подполе с указанным кодом.

**RecordField insertAt(size_t index, SubField subfield)** -- вставляет подполе в указанную позицию.

**RecordField removeAt(size_t index)** -- удаляет подполе в указанной позиции.

**RecordField removeSubField(char code)** --удаляет все подполя с указанным кодом.

**RecordField replaceSubField(char code, string oldValue, string newValue)** -- заменяет значение  подполя.

**RecordField setSubField(char code, string value)** -- устанавливает значение первого повторения подполя с указанным кодом. Если value==nil, подполе удаляется.

**string toString() const** -- возвращает строковое представление данного поля.

**bool verify() const** -- проверяет, правильно ли сформировано поле (и все его подполя).

```d
auto field = new RecordField(700);
field.append('a', "Миронов")
    .append('b', "А. В.")
    .append('g', "Алексей Владимирович");
```

#### SubField

Каждый экземпляр `SubField` содержит одно подполе записи, которое состоит из однобуквенного кода и строкового значения.

Поле  |Тип     |Назначение
------|--------|----------
code  | char   | Код подполя
value | string | Значение подполя

**this()** -- конструктор по умолчанию, создаёт пустое подполе.

**this(char code, string value)** -- конструктор, создаёт подполе с указанными кодом и значением.

**SubField clone() const** -- клонирует подполе.

**void decode(string text)** -- декодирует подполе из протокольного представления.

**string toString() const** -- выдаёт текстовое представление подполя.

**bool verify() const** -- проверяет, правильно ли сформировано подполе.

```d
auto subfield = new SubField('a', "Подполе A");
writeln(subfield);
```

#### RawRecord

Запись с нераскодированными полями/подполями. Применяется, например, для экономии усилий при перекладывании записи из одной базы в другую. В остальном аналогична `MarcRecord`.

Поле          |Тип         |Назначение
--------------|------------|----------
database      | string     | Имя базы данных, из которой загружена данная запись. Для вновь созданных записей пустая строка.
mfn           | int        | Номер записи в мастер-файле. Для вновь созданных записей 0.
status        | int        | Статус записи: логически удалена, отсутствует (аналогично `MarcRecord`).
versionNumber | int        | Номер версии записи.
fields        | string\[\] | Слайс полей записи в "сыром" виде.

**RawRecord append(int tag, string value)** -- добавляет в конец записи поле с указанными меткой и значением.

**RawRecord clone() const** -- клонирует запись со всеми полями (полная глубокая копия записи).

**bool decode(string\[\] lines)** -- декодирует запись из протокольного представления. Возвращает `false`, если декодировать запись не удалось.

**bool deleted() const** -- проверка статуса, не удалена ли запись.

**string encode(string delimiter) const** -- кодирует запись в протокольное представление.

**RawRecord insertAt(size_t index, string field)** -- вставляет поле в указанную позицию.

**RawRecord removeAt(size_t index)** -- удаляет поле в указанной позиции.

**RawRecord reset() nothrow** -- сброс состояния записи, отвязка её от базы данных. Поля данных остаются при этом нетронутыми.

**MarcRecord toMarcRecord() const** -- преобразование в `MarcRecord`.

**string toString() const** -- выдаёт строковое представление записи.

[Предыдущая глава](chapter2.md) [Следующая глава](chapter4.md)

