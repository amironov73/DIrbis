### MarcRecord, RecordField и SubField

#### MarcRecord

Каждый экземпляр `MarcRecord` соответствует одной записи в базе данных ИРБИС. Он содержит следующие поля:

Поле          |Тип              |Назначение
--------------|-----------------|----------
database      | string          | Имя базы данных, из которой загружена данная запись. Для вновь созданных записей пустая строка.
mfn           | int             | Номер записи в мастер-файле. Для вновь созданных записей 0.
status        | int             | Статус записи: логически удалена, отсутствует (см. ниже).
versionNumber | int             | Номер версии записи.
fields        | RecordField\[\] | Слайс полей записи.

Статус записи: набор флагов

Имя|Число|Значение
---|-----|--------
LOGICALLY_DELETED       | 1   | Логически удалена (может быть восстановлена).
PHYSICALLY_DELETED      | 2   | Физически удалена (не может быть восстановлена).
ABSENT                  | 4   | Отсутствует.
NON_ACTUALIZED          | 8   | Не актуализирована.
NEW_RECORD              | 16  | Первый экземпляр записи (флаг фактически не используется).
LAST                    | 32  | Последняя версия записи.
LOCKED                  | 64  | Запись заблокирована на ввод.
AUTOIN_ERROR            | 128 | Ошибка в Autoin.gbl.
FULLTEXT_NOT_ACTUALIZED | 256 | Полный текст не актуализирован.


```d
auto record = new MarcRecord;
record.append(700)
    .append('a', "Миронов")
    .append('b', "А. В.")
    .append('g', "Алексей Владимирович");
record.append(200)
    .append('a', "Заглавие книги")
	.append('e', "подзаголовочные сведения");
```

#### RecordField

Каждый экземпляр класса `RecordField` соответствует одному полю записи. Содержит числовую метку, строковое значение до первого разделителя (может быть пустым) и произвольное количество подполей.

Поле      |Тип           |Назначение
----------|--------------|----------
tag       | int          | Метка поля.
value     | string       | Значение поля до первого разделителя.
subfields | SubField\[\] | Слайс подполей.

**this(int tag=0, string value="")** -- конструктор поля, создаёт поле с указанными меткой и значением.

**RecordField append(char code, string value)** -- добавляет подполе с указанными кодом и значением к полю. Возвращает `this`, так что может испольоваться для "цепочечных" вызовов.

**RecordField adppendNonEmpty(char code, string value)** -- добавляет подполе, при условии, что его значение не пустое.

**RecordField clear()** -- очищает поле (удаляет значение и все подполя). Метка поля остаётся нетронутой. Возвращает `this`.

**RecordField clone() const** -- клонирует поле со всеми подполями.

**void decodeBody(string bodyText)** -- декодирует только текст поля и подполей (без метки).

**void decode(string text)** -- декодирует поле из протокольного представления (метку, значение и подполя).

**RecordField[] getEmbeddedFields() const** -- получает слайс встроенных полей из данного поля.

**SubField getFirstSubField(char code)** -- возвращает первое вхождение подполя с указанным кодом или `nil`.

**string getFirstSubFieldValue(char code)** -- возвращает значение первого вхождения подполя с указанным кодом или пустую строку.

**string getValueOrFirstSubField()** -- выдаёт значение для ^*.

**bool haveSubField(char code) const** -- выясняет, есть ли подполе с указанным кодом.

**RecordField insertAt(size_t index, SubField subfield)** -- вставляет подполе в указанную позицию.

**RecordField removeAt(size_t index)** -- удаляет подполе в указанной позиции.

**RecordField removeSubField(char code)** --удаляет все подполя с указанным кодом.

**RecordField replaceSubField(char code, string oldValue, string newValue)** -- заменяет значение  подполя.

**RecordField setSubField(char code, string value)** -- устанавливает значение первого повторения подполя с указанным кодом. Если value==nil, подполе удаляется.

**string toString() const** -- возвращает строковое представление данного поля.

**bool verify() const** -- проверяет, правильно ли сформировано поле (и все его подполя).

```d
auto field = new RecordField(700);
field.add('a', "Миронов")
    .add('b', "А. В.")
    .add('g', "Алексей Владимирович");
```

#### SubField

Каждый экземпляр `SubField` содержит одно подполе записи, которое состоит из однобуквенного кода и строкового значения.

Поле  |Тип     |Назначение
------|--------|----------
code  | char   | Код подполя
value | string | Значение подполя

**this()** -- конструктор по умолчанию, создаёт пустое подполе.

**this(char code, string value)** -- конструктор, создаёт подполе с указанными кодом и значением.

**SubField clone() const** -- клонирует подполе.

**void decode(string text)** -- декодирует подполе из протокольного представления.

**string toString() const** -- выдаёт текстовое представление подполя.

**bool verify() const** -- проверяет, правильно ли сформировано подполе.

```d
auto subfield = new SubField('a', "Подполе A");
writeln(subfield);
```

#### RawRecord

Запись с нераскодированными полями/подполями. Применяется, например, для экономии усилий при перекладывании записи из одной базы в другую. В остальном аналогична `MarcRecord`.

Поле          |Тип         |Назначение
--------------|------------|----------
database      | string     | Имя базы данных, из которой загружена данная запись. Для вновь созданных записей пустая строка.
mfn           | int        | Номер записи в мастер-файле. Для вновь созданных записей 0.
status        | int        | Статус записи: логически удалена, отсутствует (аналогично `MarcRecord`).
versionNumber | int        | Номер версии записи.
fields        | string\[\] | Слайс полей записи в "сыром" виде.

**bool decode(string\[\] lines)** -- декодирует запись из протокольного представления. Возвращает `false`, если декодировать запись не удалось.

**bool deleted() const** -- проверка статуса, не удалена ли запись.

**string encode(string delimiter) const** -- кодирует запись в протокольное представление.

**RawRecord reset() nothrow** -- сброс состояния записи, отвязка её от базы данных. Поля данных остаются при этом нетронутыми.

**string toString() const** -- выдаёт строковое представление записи.

[Предыдущая глава](chapter2.md) [Следующая глава](chapter4.md)



